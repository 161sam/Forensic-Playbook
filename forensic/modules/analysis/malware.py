"""Basic malware analysis hooks with optional YARA scanning."""

from __future__ import annotations

from pathlib import Path
from typing import Dict, List, Optional

from ...core.evidence import Evidence
from ...core.module import AnalysisModule, ModuleResult
from ...core.time_utils import utc_isoformat
from ...tools import yara as yara_wrapper
from ...utils import hashing, io


class MalwareAnalysisModule(AnalysisModule):
    """Perform lightweight malware triage using hashes and optional YARA."""

    @property
    def name(self) -> str:
        return "malware_analysis"

    @property
    def description(self) -> str:
        return "Hash comparison and optional YARA scanning"

    def tool_versions(self) -> Dict[str, str]:
        """Report YARA status using the guarded wrapper."""

        available = yara_wrapper.available()
        version_info = yara_wrapper.version() if available else None
        status = version_info or ("available" if available else "missing")
        return {"yara": status}

    def validate_params(self, params: Dict) -> bool:
        target = params.get("target")
        if not target:
            self.logger.error("Missing 'target' parameter")
            return False
        path = Path(target)
        if not path.exists():
            self.logger.error("Target does not exist: %s", path)
            return False
        return True

    def run(self, evidence: Optional[Evidence], params: Dict) -> ModuleResult:
        result_id = self._generate_result_id()
        timestamp = utc_isoformat()
        target_path = Path(params["target"]).resolve()
        yara_rules = params.get("yara_rules")
        findings: List[Dict[str, str]] = []
        errors: List[str] = []
        metadata: Dict[str, str] = {"target": str(target_path)}

        if target_path.is_file():
            hashes = hashing.compute_hashes(target_path, ("md5", "sha1", "sha256"))
            findings.append(
                {
                    "type": "hashes",
                    "description": "Computed file hashes",
                    **hashes,
                }
            )
            metadata.update({f"hash_{k}": v for k, v in hashes.items()})
        else:
            metadata["note"] = "Directory hashing skipped"

        yara_available = self._verify_tool("yara")
        metadata["yara_available"] = str(yara_available)

        if yara_rules and not Path(yara_rules).exists():
            errors.append(f"YARA rule file not found: {yara_rules}")
            yara_rules = None

        if yara_rules and yara_available:
            metadata["yara_rules"] = str(yara_rules)
            findings.extend(self._run_yara_scan(target_path, Path(yara_rules)))
        elif yara_rules and not yara_available:
            errors.append(
                "Requested YARA scan but 'yara' binary is not available. Install yara."
            )
        elif not yara_rules:
            errors.append(
                "No YARA rules provided. Provide --yara-rules path to enable scanning."
            )

        status = "success" if not errors else "partial"

        report_path = self.output_dir / "malware_summary.json"
        io.write_json(report_path, {"findings": findings, "metadata": metadata})

        return ModuleResult(
            result_id=result_id,
            module_name=self.name,
            status=status,
            timestamp=timestamp,
            output_path=report_path,
            findings=findings,
            metadata=metadata,
            errors=errors,
        )

    def _run_yara_scan(self, target: Path, rule_path: Path) -> List[Dict[str, str]]:
        """Execute yara in a safe manner, returning findings."""

        from subprocess import CompletedProcess, run

        cmd = ["yara", str(rule_path), str(target)]
        # TODO: use forensic.tools.* wrapper
        completed: CompletedProcess[str] = run(
            cmd, check=False, capture_output=True, text=True
        )
        findings: List[Dict[str, str]] = []

        if completed.returncode not in (0, 1):
            self.logger.warning("YARA command failed: %s", completed.stderr.strip())
            return findings

        for line in completed.stdout.strip().splitlines():
            if not line:
                continue
            parts = line.split(None, 1)
            rule = parts[0]
            matched_path = parts[1] if len(parts) > 1 else str(target)
            findings.append(
                {
                    "type": "yara_match",
                    "description": f"Rule {rule} matched",
                    "rule": rule,
                    "path": matched_path,
                }
            )
        return findings


__all__ = ["MalwareAnalysisModule"]
